{
  "name": "POST Update Stats",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "stats/update",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-post-update",
      "name": "Webhook POST Update Stats",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300],
      "webhookId": "stats-update"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "orders",
        "options": {
          "filter": {
            "conditions": []
          }
        }
      },
      "id": "get-all-orders",
      "name": "Get All Orders",
      "type": "n8n-nodes-base.n8n",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "compositions",
        "options": {
          "filter": {
            "conditions": []
          }
        }
      },
      "id": "get-all-compositions",
      "name": "Get All Compositions",
      "type": "n8n-nodes-base.n8n",
      "typeVersion": 1,
      "position": [450, 500]
    },
    {
      "parameters": {
        "jsCode": "// Calculer les stats mensuelles depuis les commandes\nconst orders = $('Get All Orders').all().map(item => item.json);\nconst compositions = $('Get All Compositions').all().map(item => item.json);\n\n// Fonction pour parser une date au format français \"DD/MM/YYYY\"\nfunction parseFrenchDate(dateStr) {\n  if (!dateStr) return null;\n  \n  // Si c'est déjà une date ISO, la parser directement\n  if (dateStr.includes('T') || dateStr.includes('-')) {\n    return new Date(dateStr);\n  }\n  \n  // Parser le format français \"DD/MM/YYYY\"\n  const parts = dateStr.split('/');\n  if (parts.length === 3) {\n    const day = parseInt(parts[0], 10);\n    const month = parseInt(parts[1], 10) - 1; // Mois 0-indexed\n    const year = parseInt(parts[2], 10);\n    return new Date(year, month, day);\n  }\n  \n  // Essayer de parser comme date standard\n  return new Date(dateStr);\n}\n\n// Créer un map des compositions par id_compo (prendre la plus récente si doublon)\nconst compMap = {};\ncompositions.forEach(comp => {\n  const idCompo = comp.id_compo || comp.id;\n  if (idCompo) {\n    // Si plusieurs compositions avec le même id_compo, garder la plus récente\n    if (!compMap[idCompo] || (comp.updatedAt && compMap[idCompo].updatedAt && comp.updatedAt > compMap[idCompo].updatedAt)) {\n      compMap[idCompo] = comp;\n    }\n  }\n});\n\n// Agrégation des stats par mois (format \"YYYY-MM\")\nconst statsByMonth = {};\n\norders.forEach(order => {\n  // Récupérer les dates (format français \"DD/MM/YYYY\")\n  const dateCreationStr = order.Date_Creation || order.date_creation || order.dateCreation;\n  const dateRecuperationStr = order.Date_Recuperation || order.date_recuperation || order.dateRecuperation;\n  \n  const dateCreation = parseFrenchDate(dateCreationStr);\n  const dateRecuperation = parseFrenchDate(dateRecuperationStr);\n  \n  // Vérifier que les dates sont valides\n  if (!dateCreation || !dateRecuperation || isNaN(dateCreation.getTime()) || isNaN(dateRecuperation.getTime())) {\n    console.log(`⚠️ Commande ${order.id} ignorée: dates invalides (${dateCreationStr} / ${dateRecuperationStr})`);\n    return; // Ignorer cette commande\n  }\n  \n  // Nombre de paniers\n  const nombrePaniers = parseInt(order.Nombre_Paniers || order.nombrePaniers || order.nombre_paniers || 1);\n  \n  // Récupérer la composition (utiliser composition_id de la commande)\n  const compositionId = order.composition_id || order.compositionId || 'comp-default';\n  const composition = compMap[compositionId];\n  \n  if (!composition) {\n    console.log(`⚠️ Commande ${order.id} ignorée: composition \"${compositionId}\" non trouvée`);\n    return; // Ignorer si composition non trouvée\n  }\n  \n  // Parser composition_json (string JSON)\n  let fruitsComposition = {};\n  if (composition.composition_json) {\n    if (typeof composition.composition_json === 'string') {\n      try {\n        fruitsComposition = JSON.parse(composition.composition_json);\n      } catch (e) {\n        console.log(`⚠️ Erreur parsing composition_json pour ${compositionId}:`, e);\n        fruitsComposition = {};\n      }\n    } else {\n      fruitsComposition = composition.composition_json;\n    }\n  }\n  \n  // Normaliser les noms de fruits en minuscules pour cohérence\n  const normalizedFruits = {};\n  Object.entries(fruitsComposition).forEach(([fruit, qty]) => {\n    const fruitKey = fruit.toLowerCase().trim();\n    normalizedFruits[fruitKey] = (normalizedFruits[fruitKey] || 0) + (parseInt(qty) || 0);\n  });\n  \n  // Calculer tous les mois entre Date_Creation et Date_Recuperation\n  const months = [];\n  const currentDate = new Date(dateCreation);\n  const endDate = new Date(dateRecuperation);\n  \n  // Normaliser les dates au début du mois\n  currentDate.setDate(1);\n  currentDate.setHours(0, 0, 0, 0);\n  endDate.setDate(1);\n  endDate.setHours(0, 0, 0, 0);\n  \n  while (currentDate <= endDate) {\n    const year = currentDate.getFullYear();\n    const month = String(currentDate.getMonth() + 1).padStart(2, '0');\n    const moisKey = `${year}-${month}`;\n    months.push(moisKey);\n    \n    // Passer au mois suivant\n    currentDate.setMonth(currentDate.getMonth() + 1);\n  }\n  \n  // Pour chaque mois, ajouter les fruits vendus\n  months.forEach(moisKey => {\n    if (!statsByMonth[moisKey]) {\n      statsByMonth[moisKey] = {\n        mois: moisKey,\n        composition_id: `stats-${moisKey}`,\n        paniers_total: 0,\n        stats_json: {}\n      };\n    }\n    \n    // Ajouter le nombre de paniers\n    statsByMonth[moisKey].paniers_total += nombrePaniers;\n    \n    // Ajouter les fruits (quantité par panier × nombre de paniers)\n    Object.entries(normalizedFruits).forEach(([fruit, qtyPerPanier]) => {\n      const qtyTotal = (parseInt(qtyPerPanier) || 0) * nombrePaniers;\n      if (!statsByMonth[moisKey].stats_json[fruit]) {\n        statsByMonth[moisKey].stats_json[fruit] = 0;\n      }\n      statsByMonth[moisKey].stats_json[fruit] += qtyTotal;\n    });\n  });\n});\n\n// Convertir en array et formater pour la DataTable\nconst statsArray = Object.values(statsByMonth).map(stat => {\n  return {\n    json: {\n      composition_id: stat.composition_id,\n      mois: stat.mois,\n      paniers_total: stat.paniers_total,\n      stats_json: JSON.stringify(stat.stats_json),\n      updatedAt: new Date().toISOString()\n    }\n  };\n});\n\nconsole.log(`✅ ${statsArray.length} mois de stats calculés`);\nreturn statsArray;"
      },
      "id": "calculate-stats",
      "name": "Calculate Stats",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [650, 400]
    },
    {
      "parameters": {
        "operation": "upsert",
        "tableId": "stats_mensuelles",
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "composition_id": "={{ $json.composition_id }}",
            "mois": "={{ $json.mois }}",
            "paniers_total": "={{ $json.paniers_total }}",
            "stats_json": "={{ $json.stats_json }}",
            "updatedAt": "={{ $json.updatedAt }}"
          }
        },
        "options": {
          "upsert": {
            "upsertFields": [
              "mois"
            ]
          }
        }
      },
      "id": "upsert-stats",
      "name": "Upsert Stats",
      "type": "n8n-nodes-base.n8n",
      "typeVersion": 1,
      "position": [850, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { success: true, message: 'Statistiques mises à jour', count: $input.all().length } }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              },
              {
                "name": "Access-Control-Allow-Methods",
                "value": "POST, OPTIONS"
              },
              {
                "name": "Access-Control-Allow-Headers",
                "value": "Content-Type"
              }
            ]
          }
        }
      },
      "id": "respond",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1050, 400]
    },
    {
      "parameters": {
        "httpMethod": "OPTIONS",
        "path": "stats/update",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-options",
      "name": "Webhook OPTIONS",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 600],
      "webhookId": "stats-update-options"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={}",
        "options": {
          "responseCode": 204,
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              },
              {
                "name": "Access-Control-Allow-Methods",
                "value": "POST, OPTIONS"
              },
              {
                "name": "Access-Control-Allow-Headers",
                "value": "Content-Type"
              }
            ]
          }
        }
      },
      "id": "respond-options",
      "name": "Respond OPTIONS",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [450, 600]
    }
  ],
  "connections": {
    "Webhook POST Update Stats": {
      "main": [
        [
          {
            "node": "Get All Orders",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get All Compositions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get All Orders": {
      "main": [
        [
          {
            "node": "Calculate Stats",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get All Compositions": {
      "main": [
        [
          {
            "node": "Calculate Stats",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Stats": {
      "main": [
        [
          {
            "node": "Upsert Stats",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upsert Stats": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook OPTIONS": {
      "main": [
        [
          {
            "node": "Respond OPTIONS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-12-08T00:00:00.000Z",
  "versionId": "1"
}

